{
  // Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and
  // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
  // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the
  // same ids are connected.
  // Example:
  // "Print to console": {
  // 	"prefix": "log",
  // 	"body": [
  // 		"console.log('$1');",
  // 		"$2"
  // 	],
  // 	"description": "Log output to console"
  // }
  "basic coding template": {
    "prefix": "include",
    "body": [
      "#include<bits/stdc++.h>",
      "using namespace std;",
      "",
      "/////////////////////////////////////////////////////////////////////////////////////////////////////////////",
      "typedef long long int ll;",
      "//////////////////////////////////////////////////////////////////////////////////////////////////////////////////",
      "#define  boost ios_base::sync_with_stdio(false);cin.tie(NULL);",
      "",
      "#define ull unsigned long long",
      "#define d1(x) cout<<#x<<\" \"<<x<<endl;",
      "#define d2(x,y) cout<<#x<<\" \"<<x<<\" \"<<#y<<\" \"<<y<<endl;",
      "#define d2i(x,y,i) cout<<#x<<i<<\" \"<<x<<\" \"<<#y<<i<<\" \"<<y<<endl;",
      "",
      "#define fr(i,l,r) for(ll i=l;i<r;i++)",
      "#define mems(a,x) memset(a,x,sizeof(a))",
      "#define mod 1000000007",
      "#define ff first",
      "#define ss second",
      "#define pb(x) push_back(x)",
      "#define vll vector<ll>",
      "#define pbp(x,y) push_back(make_pair(x,y))",
      "#define all(v) v.begin(),v.end()",
      "#define  mat vector<vector<ll>>",
      "#define el cout<<'\\n';",
      "////////////////////////////////////////////////////////////////////////////////////////////////////////////////////",
      "",
      "void solve(){$0",
      "}",
      "",
      "",
      "int main(){",
      " boost",
      " ll t=1; ",
      "cin>>t;",
      "",
      "    while(t--){",
      "      solve();",
      "   el",
      "        }",
      "    return 0;",
      "}",
      ""
    ],
    "description": "basic coding template"
  },
  "power function with modulo ": {
    "prefix": "modpow",
    "body": [
      "ll pw(ll a,ll b=mod-2){",
      "ll ans=1;",
      "while(b){",
      "  if(b&1)",
      "    ans = ans * a % mod;",
      "  a = a * a % mod;",
      "  b>>=1;",
      "  }",
      "return ans;",
      "}"
    ],
    "description": "power function with modulo "
  },
  "trie with string ": {
    "prefix": "trie",
    "body": [
      "",
      "struct node{",
      "    int cnt;",
      "    node *child[26];",
      "    node(){",
      "                    cnt=0;",
      "    ",
      "        for(int i=0;i<26;i++){",
      "",
      "            child[i]=NULL;",
      "        }",
      "    }",
      "};",
      "void add (string &s,node* root){",
      "    node *temp=root;",
      "    for(int i=0;i<s.size();i++){",
      "         int k=s[i]-'A';",
      "         if(temp->child[k]==NULL){",
      "             temp->child[k]=new node();",
      "         }",
      "        temp=temp->child[k];",
      "        temp->cnt=temp->cnt+1;",
      "        //cout<<temp->cnt<<endl;",
      "    }",
      "}",
      "ll find(node *root,ll k){",
      "",
      "      ll ans=0;",
      "      for(int i=0;i<26;i++){",
      "          if(root->child[i]!=NULL){",
      "           //   d1((root->child[i]->cnt))",
      "              ans+=find(root->child[i],k)+(root->child[i]->cnt)/k;",
      "          }",
      "          ",
      "      }",
      "      return ans;",
      "}"
    ],
    "description": "trie with string "
  },
  "main function for google competition": {
    "prefix": "googlemain",
    "body": [
      "int main(){",
      "    ll t=1;",
      "  cin>>t;",
      "  ll f=1;",
      "    while(f<=t){",
      "        cout<<\"Case #\"<<f<<\": \";",
      "        solve();",
      "        cout<<endl;",
      "        f++;",
      "    }",
      "",
      "    return 0;",
      "}"
    ],
    "description": "main function for google competition"
  },
  "disjoin ": {
    "prefix": "disjoin",
    "body": [
      "const ll N=1e5+10;",
      "ll par[N];",
      "ll size[N];",
      "void init()   //intially all the nodes are pointing to itself",
      "{",
      "for(ll i=1;i<=N;i++){",
      "    par[i]=i;",
      "    size[i]=1;",
      "}",
      "}",
      "",
      "ll parent(ll n)   //find till the node is nit found who is pointing to itself",
      "{",
      "  if(par[n]==n)",
      "  return n;",
      "  return par[n]=parent(par[n]);",
      "}",
      "",
      "void uni(ll a,ll b){",
      "  a=parent(a);",
      "  b=parent(b);",
      "",
      "  if(a==b)",
      "  return;",
      "  ",
      "  if(size[a]<size[b])",
      "  swap(a,b);",
      "  ",
      "  size[a]+=size[b];",
      "  par[b]=a;",
      "",
      "}"
    ],
    "description": "disjoin "
  },
  "dijkstra": {
    "prefix": "dijkstra",
    "body": [
      "const ll N=1e5;",
      "vector<pair<ll,ll>>g[N];",
      "bool vis[N];",
      "ll dis[N];",
      "ll n;",
      "void dijkstra(ll src){",
      "    fill(dis,dis+n+1,1e9);",
      "memset(vis,false,sizeof(vis));",
      "",
      "    dis[src]=0;",
      "    multiset<pair<ll,ll>>q;",
      "    q.insert({0,src});",
      "",
      "    while(!q.empty()){",
      "    pair<ll,ll>tp=*q.begin();",
      "    q.erase(q.begin());",
      "    ll u=tp.second,w=tp.first;",
      "    if(vis[u])",
      "    continue;",
      "    vis[u]=true;",
      "    for(auto it:g[u]){",
      "        ll v=it.second,wei=it.first;",
      "        ",
      "        if(dis[v]>dis[u]+wei){",
      "            dis[v]=dis[u]+wei;",
      "        q.insert({dis[u]+wei,v});",
      "        }",
      "    }",
      "        ",
      "    }",
      "",
      "    ",
      "}"
    ],
    "description": "dijkstra"
  },
  "range sum with lazy update ": {
    "prefix": "seglazy",
    "body": [
      "",
      "void build_tree(vll v,int* tree,ll start,ll end,ll node){",
      "    if(start==end)",
      "    {tree[node]=v[start];",
      "    return;",
      "    }",
      "    ll mid=(start+end)/2;",
      "    build_tree(v,tree,start,mid,2*node);",
      "    build_tree(v,tree,mid+1,end,2*node+1);",
      "",
      "    tree[node]=tree[2*node]+tree[2*node+1];",
      "}",
      "",
      "",
      "//***************************************************************************************************************",
      "",
      "void updatenode(int* tree,int* lazy ,int start ,int end ,int l ,int r, int node,int val){",
      "    tree[node]+=(end-start+1)*val;",
      "       //check for leaf node if not then mark lazy to its children",
      "    if(start!=end){",
      "        lazy[2*node]+=val;",
      "        lazy[2*node+1]+=val;",
      "    }",
      "    // updated ",
      "    lazy[node]=0;",
      "}",
      "",
      "",
      "",
      "",
      "// this is the function to update the range with val",
      "",
      "void updaterange(int* tree,int* lazy ,int start ,int end ,int l ,int r, int node,int val){",
      "    if(lazy[node]!=0){",
      "        // node need to be updated  here lazy[node] value to be passed to children",
      "        updatenode(tree,lazy,start,end,l,r,node,lazy[node]);",
      "    }",
      "    if(r<start || end<l)",
      "    return;",
      "    else if(start>=l && end<=r){",
      "        // here value tree[val] to be updated and val to be passed to children",
      "        //tree[node]=(r-l+1)*val;",
      "        lazy[node]=val;",
      "        // updatenode(tree,lazy,start,end,l,r,node,val);",
      "    }",
      "    else{",
      "        ll mid =(start+end)/2;",
      "        updaterange(tree,lazy,start,mid,l,r,2*node,val);",
      "        updaterange(tree,lazy,mid+1,end,l,r,2*node+1,val);",
      "        tree[node]=tree[2*node]+tree[2*node+1];",
      "    }",
      "",
      "",
      "}",
      "",
      "",
      "//******************************************************************************************",
      "",
      "int query(int* tree,int* lazy,int start,int end ,int l ,int r,int node){",
      "  // no overlap",
      "    if(r<start || end<l)",
      "    return 0;",
      "    if(lazy[node]!=0){",
      "     updatenode(tree,lazy,start,end,l,r,node,lazy[node]);",
      "     }",
      "     if(start>=l && end<=r)",
      "    return tree[node];",
      "    else{",
      "        ll mid=(start+end)/2;",
      "        return  (query(tree,lazy,start,mid,l,r,2*node)+query(tree,lazy,mid+1,end,l,r,2*node+1));",
      "            }",
      "}",
      ""
    ],
    "description": "range sum with lazy update "
  },
  "general dfs with tree": {
    "prefix": "dfs",
    "body": [
      "ll dfs(ll u,ll par){",
      "  for(ll x:g[u]){",
      "    if(x==par) continue;",
      "    dfs(x,u);",
      "  }",
      "}"
    ],
    "description": "general dfs with tree"
  },
  "digitdp ": {
    "prefix": "digitdp",
    "body": [
      "vector<int> num;",
      "int a, b, d, k;",
      "int DP[101][4][2];",
      "//DP[pos][cnt][f];",
      "/// DP[p][c][f] = Number of valid numbers <= b from this state",
      "/// p = current position from left side (zero based)",
      "/// c = number of times we have placed the digit d so far",
      "/// f = the number we are building has already become smaller than  nb? [0 =no, 1 = yes]",
      "",
      "int call(int pos, int cnt, int f){",
      "    if(cnt > k) return 0;",
      "",
      "    if(pos == num.size()){",
      "        if(cnt == k) return 1;",
      "        return 0;",
      "    }",
      "",
      "    if(DP[pos][cnt][f] != -1) return DP[pos][cnt][f];",
      "    int res = 0;",
      "",
      "    int LMT;",
      "",
      "    if(f == 0){",
      "        /// Digits we placed so far matches with the prefix of b",
      "        /// So if we place any digit > num[pos] in the current position, then the number will become greater than b",
      "        LMT = num[pos];",
      "    } else {",
      "        /// The number has already become smaller than b. We can place any digit now.",
      "        LMT = 9;",
      "    }",
      "",
      "    /// Try to place all the valid digits such that the number doesn't exceed b",
      "    for(int dgt = 0; dgt<=LMT; dgt++){",
      "        int nf = f;",
      "        int ncnt = cnt;",
      "        if(f == 0 && dgt < LMT) nf = 1; /// The number is getting smaller at this position",
      "        if(dgt != 0) ncnt++;      // given condition brother",
      "        if(ncnt <= k) res += call(pos+1, ncnt, nf);",
      "    }",
      "",
      "    return DP[pos][cnt][f] = res;",
      "}",
      "",
      "int solve(string &b){",
      "    num.resize(b.size());",
      "    for(int i=0;i<b.size();i++){",
      "    num[i]=b[i]-'0';",
      "    //cout<<num[i]<<\" \";",
      "    }",
      "    /// Stored all the digits of b in num for simplicity",
      "",
      "    memset(DP, -1, sizeof(DP));",
      "    int res = call(0, 0, 0);",
      "    return res;",
      "}"
    ],
    "description": "digitdp "
  },
  "vector": {
    "prefix": "vec",
    "body": ["vector<${1:ll}>${2:v(n)};"],
    "description": ""
  },
  "pair ": {
    "prefix": "p2",
    "body": ["pair<${1:ll},${2:ll}>$3"],
    "description": "pair "
  },
  "": {
    "prefix": "bit",
    "body": [
      "struct fen {",
      "    vector<ll> bit;  // binary indexed tree",
      "    ll n;",
      "",
      "    fen(ll n) {",
      "        this->n = n + 1;",
      "        bit.assign(n + 1, 0);",
      "    }",
      "",
      "    fen(vector<ll> a)",
      "        : fen(a.size()) {",
      "        for (ll i = 0; i < a.size(); i++)",
      "            add(i, a[i]);",
      "    }",
      "",
      "    ll sum(int idx) {",
      "        ll ret = 0;",
      "        for (++idx; idx > 0; idx -= idx & -idx)",
      "            ret += bit[idx];",
      "        return ret;",
      "    }",
      "",
      "    ll sum(ll  l, ll  r) {",
      "        return sum(r) - sum(l - 1);",
      "    }",
      "",
      "    void add(ll idx, ll delta) {",
      "        for (++idx; idx < n; idx += idx & -idx)",
      "            bit[idx] += delta;",
      "    }",
      "};"
    ],
    "description": ""
  },
  "input from input file codeforces": {
    "prefix": "input.txt",
    "body": [
      "  freopen(\"input.txt\",\"r\",stdin);",
      "    freopen(\"output.txt\",\"w\",stdout);"
    ],
    "description": "input from input file codeforces"
  },
  "seive": {
    "prefix": "seive",
    "body": [
      "const ll N=1e6+10;",
      "bool prime[N];",
      "vector<ll>p;",
      "void seive(){",
      "    ",
      "    mems(prime,true);",
      "    for(ll i=2;i*i<N;i++){",
      "           if(!prime[i]) continue;",
      "        for(ll j=i*i;j<N;j+=i){",
      "               prime[j]=false;",
      "        }",
      "    }",
      "",
      "    for(int i=2;i<N;i++)",
      "        if(prime[i])",
      "          p.pb(i);",
      "",
      "        //   cout<<p.sizse();",
      "}"
    ],
    "description": "seive"
  },
  "graph": {
    "prefix": "gp",
    "body": [
      "const ll N=2*1e5+10;",
      "vll g[N];",
      "void create(){",
      "    ll u,v;",
      "    cin>>u>>v;",
      "    g[u].pb(v);",
      "    g[v].pb(u);",
      "",
      "}"
    ],
    "description": "graph"
  },
  "breath_first_search": {
    "prefix": "bfs",
    "body": [
      "void bfs(ll source){ ",
      "     queue< ll > q;",
      "     q.push( source );",
      "     vis[source]=1;",
      "     while( !q.empty()){",
      "        auto tp = q.front();",
      "        q.pop();",
      "        for(ll x:g[tp]){",
      "            if(!vis[x]){",
      "                vis[x]=1;",
      "                // from[x]=tp;",
      "                q.push(x);",
      "            }",
      "        }",
      "     }",
      " }",
      ""
    ],
    "description": ""
  }
}
